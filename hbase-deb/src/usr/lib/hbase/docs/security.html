<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Chapter&nbsp;1.&nbsp;Secure Apache HBase</title><link rel="stylesheet" type="text/css" href="css/freebsd_docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" title="Chapter&nbsp;1.&nbsp;Secure Apache HBase"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>Chapter&nbsp;1.&nbsp;Secure Apache HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#hbase.secure.configuration">1.1. Secure Client Access to Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d6578e19">1.1.1. Prerequisites</a></span></dt><dt><span class="section"><a href="#d6578e60">1.1.2. Server-side Configuration for Secure Operation</a></span></dt><dt><span class="section"><a href="#d6578e72">1.1.3. Client-side Configuration for Secure Operation</a></span></dt><dt><span class="section"><a href="#d6578e111">1.1.4. Client-side Configuration for Secure Operation - Thrift Gateway</a></span></dt><dt><span class="section"><a href="#d6578e143">1.1.5. Client-side Configuration for Secure Operation - REST Gateway</a></span></dt><dt><span class="section"><a href="#d6578e177">1.1.6. REST Gateway Impersonation Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.secure.simpleconfiguration">1.2. Simple User Access to Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d6578e219">1.2.1. Simple Versus Secure Access</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.tags">1.3. Tags</a></span></dt><dt><span class="section"><a href="#hbase.accesscontrol.configuration">1.4. Access Control</a></span></dt><dd><dl><dt><span class="section"><a href="#d6578e359">1.4.1. Prerequisites</a></span></dt><dt><span class="section"><a href="#d6578e372">1.4.2. Overview</a></span></dt><dt><span class="section"><a href="#d6578e536">1.4.3. Server-side Configuration for Access Control</a></span></dt><dt><span class="section"><a href="#d6578e548">1.4.4. Cell level Access Control using Tags</a></span></dt><dt><span class="section"><a href="#d6578e574">1.4.5. Shell Enhancements for Access Control</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.secure.bulkload">1.5. Secure Bulk Load</a></span></dt><dt><span class="section"><a href="#hbase.visibility.labels">1.6. Visibility Labels</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.visibility.label.administration">1.6.1. Visibility Label Administration</a></span></dt><dt><span class="section"><a href="#hbase.visibility.label.configuration">1.6.2. Server  Side Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.encryption.server">1.7. Transparent Server Side Encryption</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.encryption.server.configuration">1.7.1. Configuration</a></span></dt><dt><span class="section"><a href="#hbase.encryption.server.schema">1.7.2. Setting Encryption on a CF</a></span></dt><dt><span class="section"><a href="#hbase.encryption.server.data_key_rotation">1.7.3. Data Key Rotation</a></span></dt><dt><span class="section"><a href="#hbase.encryption.server.master_key_rotation">1.7.4. Master Key Rotation</a></span></dt></dl></dd></dl></div><div class="section" title="1.1.&nbsp;Secure Client Access to Apache HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.secure.configuration"></a>1.1.&nbsp;Secure Client Access to Apache HBase</h2></div></div></div><p>Newer releases of Apache HBase (&gt;= 0.92) support optional SASL authentication of clients<sup>[<a name="d6578e10" href="#ftn.d6578e10" class="footnote">1</a>]</sup>.</p><p>This describes how to set up Apache HBase and clients for connection to secure HBase resources.</p><div class="section" title="1.1.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e19"></a>1.1.1.&nbsp;Prerequisites</h3></div></div></div><p>
        You need to have a working Kerberos KDC.
    </p><p>
        A HBase configured for secure client access is expected to be running
        on top of a secured HDFS cluster. HBase must be able to authenticate
        to HDFS services. HBase needs Kerberos credentials to interact with
        the Kerberos-enabled HDFS daemons. Authenticating a service should be
        done using a keytab file. The procedure for creating keytabs for HBase
        service is the same as for creating keytabs for Hadoop. Those steps
        are omitted here. Copy the resulting keytab files to wherever HBase
        Master and RegionServer processes are deployed and make them readable
        only to the user account under which the HBase daemons will run.
    </p><p>
        A Kerberos principal has three parts, with the form
        <code class="code">username/fully.qualified.domain.name@YOUR-REALM.COM</code>. We
        recommend using <code class="code">hbase</code> as the username portion.
    </p><p>
        The following is an example of the configuration properties for
        Kerberos operation that must be added to the
        <code class="code">hbase-site.xml</code> file on every server machine in the
        cluster. Required for even the most basic interactions with a
        secure Hadoop configuration, independent of HBase security.
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.regionserver.kerberos.principal&lt;/name&gt;
        &lt;value&gt;hbase/_HOST@YOUR-REALM.COM&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.regionserver.keytab.file&lt;/name&gt;
        &lt;value&gt;/etc/hbase/conf/keytab.krb5&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.master.kerberos.principal&lt;/name&gt;
        &lt;value&gt;hbase/_HOST@YOUR-REALM.COM&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.master.keytab.file&lt;/name&gt;
        &lt;value&gt;/etc/hbase/conf/keytab.krb5&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        Each HBase client user should also be given a Kerberos principal. This
        principal should have a password assigned to it (as opposed to a
        keytab file). The client principal's <code class="code">maxrenewlife</code> should
        be set so that it can be renewed enough times for the HBase client
        process to complete. For example, if a user runs a long-running HBase
        client process that takes at most 3 days, we might create this user's
        principal within <code class="code">kadmin</code> with: <code class="code">addprinc -maxrenewlife
        3days</code>
    </p><p>
        Long running daemons with indefinite lifetimes that require client
        access to HBase can instead be configured to log in from a keytab. For
        each host running such daemons, create a keytab with
        <code class="code">kadmin</code> or <code class="code">kadmin.local</code>. The procedure for
        creating keytabs for HBase service is the same as for creating
        keytabs for Hadoop. Those steps are omitted here. Copy the resulting
        keytab files to where the client daemon will execute and make them
        readable only to the user account under which the daemon will run.
    </p></div><div class="section" title="1.1.2.&nbsp;Server-side Configuration for Secure Operation"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e60"></a>1.1.2.&nbsp;Server-side Configuration for Secure Operation</h3></div></div></div><p>
        Add the following to the <code class="code">hbase-site.xml</code> file on every server machine in the cluster:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.security.authentication&lt;/name&gt;
        &lt;value&gt;kerberos&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.security.authorization&lt;/name&gt;
        &lt;value&gt;true&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
      &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
       A full shutdown and restart of HBase service is required when deploying
       these configuration changes.
    </p></div><div class="section" title="1.1.3.&nbsp;Client-side Configuration for Secure Operation"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e72"></a>1.1.3.&nbsp;Client-side Configuration for Secure Operation</h3></div></div></div><p>
        Add the following to the <code class="code">hbase-site.xml</code> file on every client:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.security.authentication&lt;/name&gt;
        &lt;value&gt;kerberos&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        The client environment must be logged in to Kerberos from KDC or
        keytab via the <code class="code">kinit</code> command before communication with
        the HBase cluster will be possible.
    </p><p>
        Be advised that if the <code class="code">hbase.security.authentication</code>
        in the client- and server-side site files do not match, the client will
        not be able to communicate with the cluster.
    </p><p>
        Once HBase is configured for secure RPC it is possible to optionally
        configure encrypted communication. To do so, add the following to the
        <code class="code">hbase-site.xml</code> file on every client:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.rpc.protection&lt;/name&gt;
        &lt;value&gt;privacy&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        This configuration property can also be set on a per connection basis.
        Set it in the <code class="code">Configuration</code> supplied to
        <code class="code">HTable</code>:
    </p><pre class="programlisting">
      Configuration conf = HBaseConfiguration.create();
      conf.set("hbase.rpc.protection", "privacy");
      HTable table = new HTable(conf, tablename);
    </pre><p>
        Expect a ~10% performance penalty for encrypted communication.
    </p></div><div class="section" title="1.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e111"></a>1.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway</h3></div></div></div><p>
        Add the following to the <code class="code">hbase-site.xml</code> file for every Thrift gateway:
    </p><pre class="programlisting">
    &lt;property&gt;
      &lt;name&gt;hbase.thrift.keytab.file&lt;/name&gt;
      &lt;value&gt;/etc/hbase/conf/hbase.keytab&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.thrift.kerberos.principal&lt;/name&gt;
      &lt;value&gt;$USER/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
      &lt;!-- TODO: This may need to be  HTTP/_HOST@&lt;REALM&gt; and _HOST may not work.
       You may have  to put the concrete full hostname.
       --&gt;
    &lt;/property&gt;
    </pre><p>
    </p><p>
        Substitute the appropriate credential and keytab for $USER and $KEYTAB
        respectively.
    </p><p>In order to use the Thrift API principal to interact with HBase, it is also necessary to add the <code class="code">hbase.thrift.kerberos.principal</code> to the <code class="code">_acl_</code> table. For example, to give the Thrift API principal, <code class="code">thrift_server</code>, administrative access, a command such as this one will suffice:
    </p><pre class="programlisting">
    grant 'thrift_server', 'RWCA'
    </pre><p> For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Access Control</a> section
    </p><p>
        The Thrift gateway will authenticate with HBase using the supplied
        credential. No authentication will be performed by the Thrift gateway
        itself. All client access via the Thrift gateway will use the Thrift
        gateway's credential and have its privilege.
    </p></div><div class="section" title="1.1.5.&nbsp;Client-side Configuration for Secure Operation - REST Gateway"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e143"></a>1.1.5.&nbsp;Client-side Configuration for Secure Operation - REST Gateway</h3></div></div></div><p>
        Add the following to the <code class="code">hbase-site.xml</code> file for every REST gateway:
    </p><pre class="programlisting">
    &lt;property&gt;
      &lt;name&gt;hbase.rest.keytab.file&lt;/name&gt;
      &lt;value&gt;$KEYTAB&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.rest.kerberos.principal&lt;/name&gt;
      &lt;value&gt;$USER/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
    &lt;/property&gt;
    </pre><p>
    </p><p>
        Substitute the appropriate credential and keytab for $USER and $KEYTAB
        respectively.
    </p><p>
        The REST gateway will authenticate with HBase using the supplied
        credential. No authentication will be performed by the REST gateway
        itself. All client access via the REST gateway will use the REST
        gateway's credential and have its privilege.
    </p><p>In order to use the REST API principal to interact with HBase, it is also necessary to add the <code class="code">hbase.rest.kerberos.principal</code> to the <code class="code">_acl_</code> table. For example, to give the REST API principal, <code class="code">rest_server</code>, administrative access, a command such as this one will suffice:
    </p><pre class="programlisting">
    grant 'rest_server', 'RWCA'
    </pre><p> For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Access Control</a> section
    </p><p>
        It should be possible for clients to authenticate with the HBase
        cluster through the REST gateway in a pass-through manner via SPEGNO
        HTTP authentication. This is future work.
    </p></div><div class="section" title="1.1.6.&nbsp;REST Gateway Impersonation Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e177"></a>1.1.6.&nbsp;REST Gateway Impersonation Configuration</h3></div></div></div><p>
        By default, the REST gateway doesn't support impersonation. It accesses
        the HBase on behalf of clients as the user configured as in the previous
        section. To the HBase server, all requests are from the REST gateway user.
        The actual users are unknown. You can turn on the impersonation support.
        With impersonation, the REST gateway user is a proxy user. The HBase server
        knows the acutal/real user of each request. So it can apply proper
        authorizations.
    </p><p>
        To turn on REST gateway impersonation, we need to configure HBase servers
        (masters and region servers) to allow proxy users; configure REST gateway
        to enable impersonation.
    </p><p>
        To allow proxy users, add the following to the <code class="code">hbase-site.xml</code>
        file for every HBase server:
    </p><pre class="programlisting">
   &lt;property&gt;
      &lt;name&gt;hadoop.security.authorization&lt;/name&gt;
      &lt;value&gt;true&lt;/value&gt;
   &lt;/property&gt;
   &lt;property&gt;
      &lt;name&gt;hadoop.proxyuser.$USER.groups&lt;/name&gt;
      &lt;value&gt;$GROUPS&lt;/value&gt;
   &lt;/property&gt;
   &lt;property&gt;
      &lt;name&gt;hadoop.proxyuser.$USER.hosts&lt;/name&gt;
      &lt;value&gt;$GROUPS&lt;/value&gt;
   &lt;/property&gt;
    </pre><p>
    </p><p>
        Substitute the REST gateway proxy user for $USER, and the allowed
        group list for $GROUPS.
    </p><p>
        To enable REST gateway impersonation, add the following to the
        <code class="code">hbase-site.xml</code> file for every REST gateway.
    </p><pre class="programlisting">
   &lt;property&gt;
      &lt;name&gt;hbase.rest.authentication.type&lt;/name&gt;
      &lt;value&gt;kerberos&lt;/value&gt;
   &lt;/property&gt;
   &lt;property&gt;
      &lt;name&gt;hbase.rest.authentication.kerberos.principal&lt;/name&gt;
      &lt;value&gt;HTTP/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
   &lt;/property&gt;
   &lt;property&gt;
      &lt;name&gt;hbase.rest.authentication.kerberos.keytab&lt;/name&gt;
      &lt;value&gt;$KEYTAB&lt;/value&gt;
   &lt;/property&gt;
    </pre><p>
    </p><p>
        Substitute the keytab for HTTP for $KEYTAB.
    </p></div></div><div class="section" title="1.2.&nbsp;Simple User Access to Apache HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.secure.simpleconfiguration"></a>1.2.&nbsp;Simple User Access to Apache HBase</h2></div></div></div><p>Newer releases of Apache HBase (&gt;= 0.92) support optional SASL authentication of clients<sup>[<a name="d6578e210" href="#ftn.d6578e210" class="footnote">2</a>]</sup>.</p><p>This describes how to set up Apache HBase and clients for simple user access to HBase resources.</p><div class="section" title="1.2.1.&nbsp;Simple Versus Secure Access"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e219"></a>1.2.1.&nbsp;Simple Versus Secure Access</h3></div></div></div><p>
        The following section shows how to set up simple user access. Simple user access is
        not a secure method of operating HBase. This method is used to prevent users from making
        mistakes. It can be used to mimic the Access Control using on a development system without having to
        set up Kerberos.
    </p><p>
        This method is not used to prevent malicious or hacking attempts. To make HBase secure against these
        types of attacks, you must configure HBase for secure operation. Refer to the section
        <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Secure Client Access to HBase</a> and complete all of the steps described
        there.
    </p><div class="section" title="1.2.1.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h4 class="title"><a name="d6578e229"></a>1.2.1.1.&nbsp;Prerequisites</h4></div></div></div><p>
        None
    </p><div class="section" title="1.2.1.1.1.&nbsp;Server-side Configuration for Simple User Access Operation"><div class="titlepage"><div><div><h5 class="title"><a name="d6578e234"></a>1.2.1.1.1.&nbsp;Server-side Configuration for Simple User Access Operation</h5></div></div></div><p>
        Add the following to the <code class="code">hbase-site.xml</code> file on every server machine in the cluster:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.security.authentication&lt;/name&gt;
        &lt;value&gt;simple&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.security.authorization&lt;/name&gt;
        &lt;value&gt;true&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        For 0.94, add the following to the <code class="code">hbase-site.xml</code> file on every server machine in the cluster:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.rpc.engine&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.ipc.SecureRpcEngine&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt; 
    </pre><p>
       A full shutdown and restart of HBase service is required when deploying
       these configuration changes.
    </p></div><div class="section" title="1.2.1.1.2.&nbsp;Client-side Configuration for Simple User Access Operation"><div class="titlepage"><div><div><h5 class="title"><a name="d6578e253"></a>1.2.1.1.2.&nbsp;Client-side Configuration for Simple User Access Operation</h5></div></div></div><p>
        Add the following to the <code class="code">hbase-site.xml</code> file on every client:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.security.authentication&lt;/name&gt;
        &lt;value&gt;simple&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        For 0.94, add the following to the <code class="code">hbase-site.xml</code> file on every server machine in the cluster:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.rpc.engine&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.ipc.SecureRpcEngine&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
        Be advised that if the <code class="code">hbase.security.authentication</code>
        in the client- and server-side site files do not match, the client will
        not be able to communicate with the cluster.
    </p></div><div class="section" title="1.2.1.1.3.&nbsp;Client-side Configuration for Simple User Access Operation - Thrift Gateway"><div class="titlepage"><div><div><h5 class="title"><a name="d6578e275"></a>1.2.1.1.3.&nbsp;Client-side Configuration for Simple User Access Operation - Thrift Gateway</h5></div></div></div><p>The Thrift gateway user will need access. For example, to give the Thrift API user, <code class="code">thrift_server</code>, administrative access, a command such as this one will suffice:
    </p><pre class="programlisting">
    grant 'thrift_server', 'RWCA'
    </pre><p> For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Access Control</a> section
    </p><p>
        The Thrift gateway will authenticate with HBase using the supplied
        credential. No authentication will be performed by the Thrift gateway
        itself. All client access via the Thrift gateway will use the Thrift
        gateway's credential and have its privilege.
    </p></div><div class="section" title="1.2.1.1.4.&nbsp;Client-side Configuration for Simple User Access Operation - REST Gateway"><div class="titlepage"><div><div><h5 class="title"><a name="d6578e291"></a>1.2.1.1.4.&nbsp;Client-side Configuration for Simple User Access Operation - REST Gateway</h5></div></div></div><p>
        The REST gateway will authenticate with HBase using the supplied
        credential. No authentication will be performed by the REST gateway
        itself. All client access via the REST gateway will use the REST
        gateway's credential and have its privilege.
    </p><p>The REST gateway user will need access. For example, to give the REST API user, <code class="code">rest_server</code>, administrative access, a command such as this one will suffice:
    </p><pre class="programlisting">
    grant 'rest_server', 'RWCA'
    </pre><p> For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Access Control</a> section
    </p><p>
        It should be possible for clients to authenticate with the HBase
        cluster through the REST gateway in a pass-through manner via SPEGNO
        HTTP authentication. This is future work.
    </p></div></div></div></div><div class="section" title="1.3.&nbsp;Tags"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.tags"></a>1.3.&nbsp;Tags</h2></div></div></div><p>
	Every cell can have metadata associated with it.  Adding metadata in the data part of every cell would make things difficult.
</p><p>
	The 0.98 version of HBase solves this problem by providing Tags along with the cell format. 
	Some of the usecases that uses the tags are Visibility labels, Cell level ACLs, etc.
</p><p>
	HFile V3 version from 0.98 onwards supports tags and this feature can be turned on using the following configuration
</p><pre class="programlisting">
      &lt;property&gt;
	    &lt;name&gt;hfile.format.version&lt;/name&gt;
        &lt;value&gt;3&lt;/value&gt;
      &lt;/property&gt;
    </pre><p>
	Every cell can have zero or more tags. Every tag has a type and the actual tag byte array.
	The types <span class="command"><strong>0-31</strong></span> are reserved for System tags.  For example &#8216;1&#8217; is reserved for ACL and &#8216;2&#8217; is reserved for Visibility tags.
</p><p>
	The way rowkeys, column families, qualifiers and values are encoded using different Encoding Algos, similarly the tags can also be encoded.  
	Tag encoding can be turned on per CF.  Default is always turn ON.
	To turn on the tag encoding on the HFiles use
</p><pre class="programlisting">
    HColumnDescriptor#setCompressTags(boolean compressTags)
    </pre><p>
	Note that encoding of tags takes place only if the DataBlockEncoder is enabled for the CF.
</p><p>
	As we compress the WAL entries using Dictionary the tags present in the WAL can also be compressed using Dictionary.  
	Every tag is compressed individually using WAL Dictionary.  To turn ON tag compression in WAL dictionary enable the property
</p><pre class="programlisting">
    &lt;property&gt;
    	&lt;name&gt;hbase.regionserver.wal.tags.enablecompression&lt;/name&gt;
    	&lt;value&gt;true&lt;/value&gt;
	&lt;/property&gt;
    </pre><p>
	To add tags to every cell during Puts, the following apis are provided
</p><pre class="programlisting">
	Put#add(byte[] family, byte [] qualifier, byte [] value, Tag[] tag)
	Put#add(byte[] family, byte[] qualifier, long ts, byte[] value, Tag[] tag)
    </pre><p>
	Some of the feature developed using tags are Cell level ACLs and Visibility labels.  
	These are some features that use tags framework and allows users to gain better security features on cell level.
</p><p>
	For details checkout 
</p><p>
    <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Access Control</a>
    <a class="link" href="#hbase.visibility.labels" title="1.6.&nbsp;Visibility Labels">Visibility labels</a>
</p></div><div class="section" title="1.4.&nbsp;Access Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.accesscontrol.configuration"></a>1.4.&nbsp;Access Control</h2></div></div></div><p>
        Newer releases of Apache HBase (&gt;= 0.92) support optional access control
        list (ACL-) based protection of resources on a column family and/or
        table basis.
    </p><p>
        This describes how to set up Secure HBase for access control, with an
        example of granting and revoking user permission on table resources
        provided.
    </p><div class="section" title="1.4.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e359"></a>1.4.1.&nbsp;Prerequisites</h3></div></div></div><p>
       You must configure HBase for secure or simple user access operation. Refer to the
       <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Secure Client Access to HBase</a> or
       <a class="link" href="#">Simple User Access to HBase</a>
        sections and complete all of the steps described
       there.
    </p><p>
       For secure access, you must also configure ZooKeeper for secure operation. Changes to ACLs
       are synchronized throughout the cluster using ZooKeeper. Secure
       authentication to ZooKeeper must be enabled or otherwise it will be
       possible to subvert HBase access control via direct client access to
       ZooKeeper. Refer to the section on secure ZooKeeper configuration and
       complete all of the steps described there.
    </p></div><div class="section" title="1.4.2.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e372"></a>1.4.2.&nbsp;Overview</h3></div></div></div><p>
        With Secure RPC and Access Control enabled, client access to HBase is
        authenticated and user data is private unless access has been
        explicitly granted. Access to data can be granted at a table or per
        column family basis.
    </p><p>
        However, the following items have been left out of the initial
        implementation for simplicity:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Row-level or per value (cell): Using Tags in HFile V3</p></li><li class="listitem"><p>Push down of file ownership to HDFS: HBase is not designed for the case where files may have different permissions than the HBase system principal. Pushing file ownership down into HDFS would necessitate changes to core code. Also, while HDFS file ownership would make applying quotas easy, and possibly make bulk imports more straightforward, it is not clear that it would offer a more secure setup.</p></li><li class="listitem"><p>HBase managed "roles" as collections of permissions: We will not model "roles" internally in HBase to begin with. We instead allow group names to be granted permissions, which allows external modeling of roles via group membership. Groups are created and manipulated externally to HBase, via the Hadoop group mapping service.</p></li></ol></div><p>
Access control mechanisms are mature and fairly standardized in the relational database world. The HBase implementation approximates current convention, but HBase has a simpler feature set than relational databases, especially in terms of client operations. We don't distinguish between an insert (new record) and update (of existing record), for example, as both collapse down into a Put. Accordingly, the important operations condense to four permissions: READ, WRITE, CREATE, and ADMIN.
    </p><div class="table"><a name="d6578e391"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Operation To Permission Mapping</b></p><div class="table-contents"><table summary="Operation To Permission Mapping" border="1"><colgroup><col align="center" class="c1"><col align="left" class="c2"></colgroup><thead><tr><th align="center">Permission</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="center">Read</td><td align="left">Get</td></tr><tr><td align="center">&nbsp;</td><td align="left">Exists</td></tr><tr><td align="center">&nbsp;</td><td align="left">Scan</td></tr><tr><td align="center">Write</td><td align="left">Put</td></tr><tr><td align="center">&nbsp;</td><td align="left">Delete</td></tr><tr><td align="center">&nbsp;</td><td align="left">Lock/UnlockRow</td></tr><tr><td align="center">&nbsp;</td><td align="left">IncrementColumnValue</td></tr><tr><td align="center">&nbsp;</td><td align="left">CheckAndDelete/Put</td></tr><tr><td align="center">&nbsp;</td><td align="left">Flush</td></tr><tr><td align="center">&nbsp;</td><td align="left">Compact</td></tr><tr><td align="center">Create</td><td align="left">Create</td></tr><tr><td align="center">&nbsp;</td><td align="left">Alter</td></tr><tr><td align="center">&nbsp;</td><td align="left">Drop</td></tr><tr><td align="center">Admin</td><td align="left">Enable/Disable</td></tr><tr><td align="center">&nbsp;</td><td align="left">Snapshot/Restore/Clone</td></tr><tr><td align="center">&nbsp;</td><td align="left">Split</td></tr><tr><td align="center">&nbsp;</td><td align="left">Major Compact</td></tr><tr><td align="center">&nbsp;</td><td align="left">Grant</td></tr><tr><td align="center">&nbsp;</td><td align="left">Revoke</td></tr><tr><td align="center">&nbsp;</td><td align="left">Shutdown</td></tr></tbody></table></div></div><br class="table-break"><p>
        Permissions can be granted in any of the following scopes, though
        CREATE and ADMIN permissions are effective only at table scope.
    </p><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Table</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Read: User can read from any column family in table</p></li><li class="listitem"><p>Write: User can write to any column family in table</p></li><li class="listitem"><p>Create: User can alter table attributes; add, alter, or drop column families; and drop the table.</p></li><li class="listitem"><p>Admin: User can alter table attributes; add, alter, or drop column families; and enable, disable, or drop the table. User can also trigger region (re)assignments or relocation.</p></li></ul></div><p>
        </p></li><li class="listitem"><p>Column Family</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Read: User can read from the column family</p></li><li class="listitem"><p>Write: User can write to the column family</p></li></ul></div><p>
        </p></li></ul></div><p>
    </p><p>
       There is also an implicit global scope for the superuser.
    </p><p>
       The superuser is a principal, specified in the HBase site configuration
       file, that has equivalent access to HBase as the 'root' user would on a
       UNIX derived system. Normally this is the principal that the HBase
       processes themselves authenticate as. Although future versions of HBase
       Access Control may support multiple superusers, the superuser privilege
       will always include the principal used to run the HMaster process. Only
       the superuser is allowed to create tables, switch the balancer on or
       off, or take other actions with global consequence. Furthermore, the
       superuser has an implicit grant of all permissions to all resources.
    </p><p>
       Tables have a new metadata attribute: OWNER, the user principal who owns
       the table. By default this will be set to the user principal who creates
       the table, though it may be changed at table creation time or during an
       alter operation by setting or changing the OWNER table attribute. Only a
       single user principal can own a table at a given time. A table owner will
       have all permissions over a given table.
    </p></div><div class="section" title="1.4.3.&nbsp;Server-side Configuration for Access Control"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e536"></a>1.4.3.&nbsp;Server-side Configuration for Access Control</h3></div></div></div><p>
        Enable the AccessController coprocessor in the cluster configuration
        and restart HBase. The restart can be a rolling one. Complete the
        restart of all Master and RegionServer processes before setting up
        ACLs.
    </p><p>
        To enable the AccessController, modify the <code class="code">hbase-site.xml</code> file on every server machine in the cluster to look like:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
      &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,
        org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
      &lt;/property&gt;
    </pre></div><div class="section" title="1.4.4.&nbsp;Cell level Access Control using Tags"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e548"></a>1.4.4.&nbsp;Cell level Access Control using Tags</h3></div></div></div><p>
    	Prior to HBase 0.98 access control was restricted to table and column family level.  Thanks to tags feature in 0.98 that allows Access control on a cell level.
		The existing Access Controller coprocessor helps in achieving cell level access control also.
		For details on configuring it refer to <a class="link" href="#hbase.accesscontrol.configuration" title="1.4.&nbsp;Access Control">Access Control</a> section.
    </p><p>
    	The ACLs can be specified for every mutation using the APIs
    </p><pre class="programlisting">
    	Mutation.setACL(String user, Permission perms)
	  	Mutation.setACL(Map&lt;String, Permission&gt; perms)
    </pre><p>
    	For example, to provide read permission to an user &#8216;user1&#8217; then
    </p><pre class="programlisting">
    	put.setACL(&#8220;user1&#8221;, new Permission(Permission.Action.READ))
    </pre><p>
    	Generally the ACL applied on the table and CF takes precedence over Cell level ACL.  In order to make the cell level ACL to take precedence use the following API,
    </p><pre class="programlisting">
    	Mutation.setACLStrategy(boolean cellFirstStrategy)
    </pre><p>
    	Please note that inorder to use this feature, HFile V3 version should be turned on.
    </p><pre class="programlisting">
   		&lt;property&gt;
			&lt;name&gt;hfile.format.version&lt;/name&gt;
			&lt;value&gt;3&lt;/value&gt;
		&lt;/property&gt;
     </pre><p>
    	Note that deletes with ACLs do not have any effect.
		To keep things simple the ACLs applied on the current Put does not change the ACL of any previous Put in the sense
		that the ACL on the current put does not affect older versions of Put for the same row.
    </p></div><div class="section" title="1.4.5.&nbsp;Shell Enhancements for Access Control"><div class="titlepage"><div><div><h3 class="title"><a name="d6578e574"></a>1.4.5.&nbsp;Shell Enhancements for Access Control</h3></div></div></div><p>
The HBase shell has been extended to provide simple commands for editing and updating user permissions. The following commands have been added for access control list management:
    </p>
    Grant
    <p>
    </p><pre class="programlisting">
    grant &lt;user|@group&gt; &lt;permissions&gt; [ &lt;table&gt; [ &lt;column family&gt; [ &lt;column qualifier&gt; ] ] ]
    </pre><p>
    </p><p>
    <code class="code">&lt;user|@group&gt;</code> is user or group  (start with character '@'), Groups are created and manipulated via the Hadoop group mapping service.
    </p><p>
    <code class="code">&lt;permissions&gt;</code> is zero or more letters from the set "RWCA": READ('R'), WRITE('W'), CREATE('C'), ADMIN('A').
    </p><p>
    Note: Grants and revocations of individual permissions on a resource are both accomplished using the <code class="code">grant</code> command. A separate <code class="code">revoke</code> command is also provided by the shell, but this is for fast revocation of all of a user's access rights to a given resource only.
    </p><p>
    Revoke
    </p><p>
    </p><pre class="programlisting">
    revoke &lt;user|@group&gt; [ &lt;table&gt; [ &lt;column family&gt; [ &lt;column qualifier&gt; ] ] ]
    </pre><p>
    </p><p>
    Alter
    </p><p>
    The <code class="code">alter</code> command has been extended to allow ownership assignment:
    </p><pre class="programlisting">
      alter 'tablename', {OWNER =&gt; 'username|@group'}
    </pre><p>
    </p><p>
    User Permission
    </p><p>
    The <code class="code">user_permission</code> command shows all access permissions for the current user for a given table:
    </p><pre class="programlisting">
      user_permission &lt;table&gt;
    </pre><p>
    </p></div></div><div class="section" title="1.5.&nbsp;Secure Bulk Load"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.secure.bulkload"></a>1.5.&nbsp;Secure Bulk Load</h2></div></div></div><p>
	Bulk loading in secure mode is a bit more involved than normal setup, since the client has to transfer the ownership of the files generated from the mapreduce job to HBase. Secure bulk loading is implemented by a coprocessor, named <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/security/access/SecureBulkLoadEndpoint.html" target="_top">SecureBulkLoadEndpoint</a>. SecureBulkLoadEndpoint uses a staging directory <code class="code">"hbase.bulkload.staging.dir"</code>, which defaults to <code class="code">/tmp/hbase-staging/</code>. The algorithm is as follows.
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Create an hbase owned staging directory which is world traversable (<code class="code">-rwx--x--x, 711</code>) <code class="code">/tmp/hbase-staging</code>. </li><li class="listitem">A user writes out data to his secure output directory: /user/foo/data </li><li class="listitem">A call is made to hbase to create a secret staging directory
  which is globally readable/writable (<code class="code">-rwxrwxrwx, 777</code>): /tmp/hbase-staging/averylongandrandomdirectoryname</li><li class="listitem">The user makes the data world readable and writable, then moves it
  into the random staging directory, then calls bulkLoadHFiles()</li></ul></div><p>
  </p><p>
  Like delegation tokens the strength of the security lies in the length
  and randomness of the secret directory.
    </p><p>
        You have to enable the secure bulk load to work properly. You can modify the <code class="code">hbase-site.xml</code> file on every server machine in the cluster and add the SecureBulkLoadEndpoint class to the list of regionserver coprocessors:
    </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;hbase.bulkload.staging.dir&lt;/name&gt;
        &lt;value&gt;/tmp/hbase-staging&lt;/value&gt;
      &lt;/property&gt;
      &lt;property&gt;
        &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,
        org.apache.hadoop.hbase.security.access.AccessController,org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint&lt;/value&gt;
      &lt;/property&gt;
    </pre></div><div class="section" title="1.6.&nbsp;Visibility Labels"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.visibility.labels"></a>1.6.&nbsp;Visibility Labels</h2></div></div></div><p>
	This feature provides cell level security with labeled visibility for the cells. Cells can be associated with a visibility expression. The visibility expression can contain labels joined with logical expressions '&amp;', '|' and '!'. Also using '(', ')' one can specify the precedence order. For example, consider the label set { confidential, secret, topsecret, probationary }, where the first three are sensitivity classifications and the last describes if an employee is probationary or not. If a cell is stored with this visibility expression:
	( secret | topsecret ) &amp; !probationary
	</p><p>
	Then any user associated with the secret or topsecret label will be able to view the cell, as long as the user is not also associated with the probationary label. Furthermore, any user only associated with the confidential label, whether probationary or not, will not see the cell or even know of its existence.
	</p><p>
	Visibility expressions like the above can be added when storing or mutating a cell using the API,
	</p><p><code class="code">Mutation#setCellVisibility(new CellVisibility(String labelExpession));</code></p>
	Where the labelExpression could be '( secret | topsecret ) &amp; !probationary'
	
	<p>
	We build the user's label set in the RPC context when a request is first received by the HBase RegionServer. How users are associated with labels is pluggable. The default plugin passes through labels specified in Authorizations added to the Get or Scan and checks those against the calling user's authenticated labels list. When client passes some labels for which the user is not authenticated, this default algorithm will drop those. One can pass a subset of user authenticated labels via the Scan/Get authorizations.
	</p><p><code class="code">Get#setAuthorizations(new Authorizations(String,...));</code></p><p><code class="code">Scan#setAuthorizations(new Authorizations(String,...));</code></p><div class="section" title="1.6.1.&nbsp;Visibility Label Administration"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.visibility.label.administration"></a>1.6.1.&nbsp;Visibility Label Administration</h3></div></div></div><p>
		There are new client side Java APIs and shell commands for performing visibility labels administrative actions. Only the HBase super user is authorized to perform these operations.
		</p><div class="section" title="1.6.1.1.&nbsp;Adding Labels"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.visibility.label.administration.add.label"></a>1.6.1.1.&nbsp;Adding Labels</h4></div></div></div><p>A set of labels can be added to the system either by using the Java API</p><p><code class="code">VisibilityClient#addLabels(Configuration conf, final String[] labels)</code></p><p>Or by using the shell command</p><p><code class="code">add_labels [label1, label2]</code></p><p>
			Valid label can include alphanumeric characters and characters '-', '_', ':', '.' and '/'
			</p></div><div class="section" title="1.6.1.2.&nbsp;User Label Association"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.visibility.label.administration.add.label"></a>1.6.1.2.&nbsp;User Label Association</h4></div></div></div><p>A set of labels can be associated with a user by using the API</p><p><code class="code">VisibilityClient#setAuths(Configuration conf, final String[] auths, final String user)</code></p><p>Or by using the shell command</p><p><code class="code">set_auths user,[label1, label2].</code></p><p>Labels can be disassociated from a user using API</p><p><code class="code">VisibilityClient#clearAuths(Configuration conf, final String[] auths, final String user)</code></p><p>Or by using shell command</p><p><code class="code">clear_auths user,[label1, label2]</code></p><p>
			One can use the API <code class="code">VisibilityClient#getAuths(Configuration conf, final String user)</code> or <code class="code">get_auths</code> shell command to get the list of labels associated for a given user. The labels and user auths information will be stored in the system table "labels".
			</p></div></div><div class="section" title="1.6.2.&nbsp;Server Side Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.visibility.label.configuration"></a>1.6.2.&nbsp;Server  Side Configuration</h3></div></div></div><p>
		HBase stores cell level labels as cell tags. HFile version 3 adds the cell tags support. Be sure to use HFile version 3 by setting this property in every server site configuration file:
		</p><pre class="programlisting">
		  &lt;property&gt;
		    &lt;name&gt;hfile.format.version&lt;/name&gt;
			&lt;value&gt;3&lt;/value&gt;
		  &lt;/property&gt;
		</pre><p>
		You will also need to make sure the VisibilityController coprocessor is active on every table to protect by adding it to the list of system coprocessors in the server site configuration files:
		</p><pre class="programlisting">
		  &lt;property&gt;
		    &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
			&lt;value&gt;org.apache.hadoop.hbase.security.visibility.VisibilityController&lt;/value&gt;
		  &lt;/property&gt;
		  &lt;property&gt;
		    &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
			&lt;value&gt;org.apache.hadoop.hbase.security.visibility.VisibilityController&lt;/value&gt;
		  &lt;/property&gt;
		</pre><p>
		As said above, finding out labels authenticated for a given get/scan request is a pluggable algorithm. A custom implementation can be plugged in using the property <code class="code">hbase.regionserver.scan.visibility.label.generator.class</code>. The default implementation class is <code class="code">org.apache.hadoop.hbase.security.visibility.DefaultScanLabelGenerator</code>
		</p></div></div><div class="section" title="1.7.&nbsp;Transparent Server Side Encryption"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.encryption.server"></a>1.7.&nbsp;Transparent Server Side Encryption</h2></div></div></div><p>
This feature provides transparent encryption for protecting HFile and WAL data at rest, using a two-tier key architecture for flexible and non-intrusive key rotation.
    </p><p>
First, the administrator provisions a cluster master key, stored into a key provider accessable to every trusted HBase process: the Master, the RegionServers, and clients (e.g. the shell) on administrative workstations. The default key provider integrates with the Java KeyStore API and any key management system with support for it. How HBase retrieves key material is configurable via the site file. The master key may be stored on the cluster servers, protected by a secure KeyStore file, or on an external keyserver, or in a hardware security module. This master key is resolved as needed by HBase processes through the configured key provider.
    </p><p>
Then, encryption keys can be specified in schema on a per column family basis, by creating or modifying a column descriptor to include two additional attributes: the name of the encryption algorithm to use (currently only "AES" is supported), and, optionally, a data key wrapped (encrypted) with the cluster master key. Per CF keys facilitates low impact incremental key rotation and reduces the scope of any external leak of key material. The wrapped data key is stored in the CF schema metadata, and in each HFile for the CF, encrypted with the cluster master key. Once the CF is configured for encryption, any new HFiles will be written encrypted. To insure encryption of all HFiles, trigger a major compaction after first enabling this feature. The key for decryption, encrypted with the cluster master key, is stored in the HFiles in a new meta block. At file open time the data key will be extracted from the HFile, decrypted with the cluster master key, and used for decryption of the remainder of the HFile. The HFile will be unreadable if the master key is not available. Should remote users somehow acquire access to the HFile data because of some lapse in HDFS permissions or from inappropriately discarded media, there will be no means to decrypt either the data key or the file data.
    </p><p>
Specifying a data key in the CF schema is optional. If one is not present, a random data key will be created for each HFile.
    </p><p>
A new configuration option for encrypting the WAL is also introduced. Even though WALs are transient, it is necessary to encrypt the WALEdits to avoid circumventing HFile protections for encrypted column families.
    </p><div class="section" title="1.7.1.&nbsp;Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.encryption.server.configuration"></a>1.7.1.&nbsp;Configuration</h3></div></div></div><p>
Create a secret key of appropriate length for AES.
        </p><pre class="programlisting">
        $ keytool -keystore /path/to/hbase/conf/hbase.jks \
          -storetype jceks -storepass &lt;password&gt; \
          -genseckey -keyalg AES -keysize 128 \
          -alias &lt;alias&gt;
	</pre><p>
where &lt;password&gt; is the password for the KeyStore file and &lt;alias&gt;is the user name of the HBase service account, typically "hbase". Simply press RETURN to store the key with the same password as the store. The resulting file should be distributed to all nodes running HBase daemons, with file ownership and permissions set to be readable only by the HBase service account.
        </p><p>
Configure HBase daemons to use a key provider backed by the KeyStore files for retrieving the cluster master key as needed.
        </p><pre class="programlisting">
        &lt;property&gt;
            &lt;name&gt;hbase.crypto.keyprovider&lt;/name&gt;
            &lt;value&gt;org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
            &lt;name&gt;hbase.crypto.keyprovider.parameters&lt;/name&gt;
            &lt;value&gt;jceks:///path/to/hbase/conf/hbase.jks?password=&lt;password&gt;&lt;/value&gt;
        &lt;/property&gt;
        </pre><p>
By default the HBase service account name will be used to resolve the cluster master key, but you can store it with any arbitrary alias and configure HBase appropriately:
        </p><pre class="programlisting">
        &lt;property&gt;
            &lt;name&gt;hbase.crypto.master.key.name&lt;/name&gt;
            &lt;value&gt;hbase&lt;/value&gt;
        &lt;/property&gt;
        </pre><p>
Because the password to the key store is sensitive information, the HBase site XML file should also have its permissions set to be readable only by the HBase service account.
        </p><p>
Transparent encryption is a feature of HFile version 3. Be sure to use HFile version 3 by setting this property in every server site configuration file:
        </p><pre class="programlisting">
        &lt;property&gt;
            &lt;name&gt;hfile.format.version&lt;/name&gt;
            &lt;value&gt;3&lt;/value&gt;
        &lt;/property&gt;
        </pre><p>
Finally, configure the secure WAL in every server site configuration file:
        </p><pre class="programlisting">
        &lt;property&gt;
            &lt;name&gt;hbase.regionserver.hlog.reader.impl&lt;/name&gt;
            &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
            &lt;name&gt;hbase.regionserver.hlog.writer.impl&lt;/name&gt;
            &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
            &lt;name&gt;hbase.regionserver.wal.encryption&lt;/name&gt;
            &lt;value&gt;true&lt;/value&gt;
        &lt;/property&gt;
        </pre></div><div class="section" title="1.7.2.&nbsp;Setting Encryption on a CF"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.encryption.server.schema"></a>1.7.2.&nbsp;Setting Encryption on a CF</h3></div></div></div><p>
To enable encryption on a CF, use <code class="code">HBaseAdmin#modifyColumn</code> or the HBase shell to modify the column descriptor. The attribute 'ENCRYPTION' specifies the encryption algorithm to use. Currently only "AES" is supported. If creating a new table, simply set this attribute; no subsequent table modification will be necessary.
        </p><p>
If setting a specific data key, the attribute 'ENCRYPTION_KEY' should contain the data key wrapped by the cluster master key. The static methods <code class="code">wrapKey</code> and <code class="code">unwrapKey</code> in <code class="code">org.apache.hadoop.hbase.security.EncryptionUtil</code> can be used in conjunction with <code class="code">HColumnDescriptor#setEncryptionKey</code> for this purpose. Because this must be done programatically, setting a data key with the shell is not supported.
        </p><p>
To disable encryption on a CF, simply remove the 'ENCRYPTION' (and 'ENCRYPTION_KEY', if it was set) attributes from the column schema, using <code class="code">HBaseAdmin#modifyColumn</code> or the HBase shell. All new HFiles for the CF will be written without encryption. Trigger a major compaction to rewrite all files.
	</p></div><div class="section" title="1.7.3.&nbsp;Data Key Rotation"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.encryption.server.data_key_rotation"></a>1.7.3.&nbsp;Data Key Rotation</h3></div></div></div><p>
Data key rotation is made simple by this design. First, change the CF key in the column descriptor. Then, trigger major compaction. Once compaction has completed, all files will be (re)encrypted with the new key material. While this process is ongoing, HFiles encrypted with old key material will still be readable. 
        </p></div><div class="section" title="1.7.4.&nbsp;Master Key Rotation"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.encryption.server.master_key_rotation"></a>1.7.4.&nbsp;Master Key Rotation</h3></div></div></div><p>
Master key rotation can be achieved by updating the KeyStore to contain a new master key, as described above, with also the old master key added to the KeyStore under a different alias. Then, configure fallback to the old master key in the HBase site file:
        </p><pre class="programlisting">
        &lt;property&gt;
            &lt;name&gt;hbase.crypto.master.alternate.key.name&lt;/name&gt;
            &lt;value&gt;hbase.old&lt;/value&gt;
        &lt;/property&gt;
        </pre><p>
This will require a rolling restart of the HBase daemons to take effect. As with data key rotation, trigger a major compaction and wait for it to complete. Once compaction has completed, all files will be (re)encrypted with data keys wrapped by the new cluster master key. The old master key, and its associated site file configuration, can then be removed, and all trace of the old master key will be gone after the next rolling restart. A second rolling restart is not immediately necessary.
        </p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d6578e10" href="#d6578e10" class="para">1</a>] </sup>See
    also Matteo Bertozzi's article on <a class="link" href="http://www.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/" target="_top">Understanding User Authentication and Authorization in Apache HBase</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.d6578e210" href="#d6578e210" class="para">2</a>] </sup>See
    also Matteo Bertozzi's article on <a class="link" href="http://www.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/" target="_top">Understanding User Authentication and Authorization in Apache HBase</a>.</p></div></div></div><div id="disqus_thread"></div><script type="text/javascript">
    var disqus_shortname = 'hbase'; // required: replace example with your forum shortname
    var disqus_url = 'http://hbase.apache.org/book';
    var disqus_identifier = 'security';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></body></html>